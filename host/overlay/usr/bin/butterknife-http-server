#!/usr/bin/python3
# encoding: utf-8

import subprocess
import os
import falcon
import unicodedata
import shutil
import stat
import json
import re
from time import sleep
from datetime import datetime, date
import pwd

from optparse import OptionParser

parser = OptionParser()
parser.add_option("-b", "--pool", default="/var/butterknife/pool", help="Btrfs pool path, defaults to")
parser.add_option("-c", "--comment", help="Comment for snapshot")
parser.add_option("-u", "--user", default="root", help="Run as user")
parser.add_option("-p", "--port", default=80, help="Bind port")
parser.add_option("-a", "--address", default="0.0.0.0", help="Bind address")

options, args = parser.parse_args()


class MyEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, datetime):
            return obj.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3] + "Z"
        if isinstance(obj, date):
            return obj.strftime('%Y-%m-%d')
        if isinstance(obj, map):
            return tuple(obj)
        return json.JSONEncoder.default(self, obj)

def serialize(func):
    """
    Falcon response serialization
    """
    def wrapped(instance, req, resp, **kwargs):
        assert not req.get_param("unicode") or req.get_param("unicode") == u"âœ“", "Unicode sanity check failed"

        # Default to no caching of API calls
        resp.set_header("Cache-Control", "no-cache, no-store, must-revalidate");
        resp.set_header("Pragma", "no-cache");
        resp.set_header("Expires", "0");

        r = func(instance, req, resp, **kwargs)

        if not resp.body:
            if not req.client_accepts_json:
                raise falcon.HTTPUnsupportedMediaType(
                    'This API only supports the JSON media type.',
                    href='http://docs.examples.com/api/json')
            resp.set_header('Content-Type', 'application/json')
            resp.body = json.dumps(r, cls=MyEncoder)
        return r

    # Pipe API docs
    wrapped._apidoc = getattr(func, "_apidoc", {})
    wrapped.__doc__ = func.__doc__
    return wrapped

class TemplateResource(object):
    @serialize
    def on_get(self, req, resp):
        def list_templates():
            for entry in os.listdir(options.pool):
                if entry.startswith("@template:"):
                    _, fqn, arch, version = entry.split(":")
                    yield tuple(fqn.rsplit(".", 1))

        return {"templates": map(
            lambda ab:{"namespace": ab[0], "identifier":ab[1]},
            set(list_templates()))}

class VersionResource(object):
    @serialize
    def on_get(self, req, resp, name, arch):
        def list_versions():
            for entry in os.listdir(options.pool):
                if entry.startswith("@template:"):
                    _, fqn, a, version = entry.split(":")

                    if name == fqn and arch == a:
                        yield version
 
        return { "versions": map(
            lambda v:{"identifier":v},
            sorted(list_versions(), reverse=True, key=lambda j:int(j[4:]))) }

class StreamingResource(object):
    def on_get(self, req, resp, name, arch, version):
        snapshot = "@template:%(name)s:%(arch)s:%(version)s" % locals()

        sources = req.get_param("src")
        suggested_filename = "%(name)s:%(arch)s:%(version)s" % locals()
        if sources:
            suggested_filename += "_from_" + sources.replace(",", "_")
        suggested_filename += ".far"

        path = os.path.join(options.pool, snapshot.replace("/", ""))
        resp.set_header("Content-Disposition", "attachment; filename=\"%s\"" % suggested_filename)
        resp.set_header('Content-Type', 'application/btrfs-stream')

        cmd = "/sbin/btrfs", "send", path

        if uid:
            cmd = ("sudo",) + cmd

        if sources:
            for source in sources.split(","):
                if not source:
                    continue
                snapshot = "@template:%(name)s:%(arch)s:%(source)s" % locals()
                cmd += ("-c", os.path.join(options.pool, snapshot.replace("/", "")))
        print("Executing:", " ".join(cmd))

        streamer = subprocess.Popen(cmd, stdout=subprocess.PIPE)
        resp.stream = streamer.stdout

        accepted_encodings = req.get_header("Accept-Encoding") or ""
        accepted_encodings = [j.strip() for j in accepted_encodings.lower().split(",")]

        if "gzip" in accepted_encodings:
            for cmd in "/usr/bin/pigz", "/bin/gzip":
                if os.path.exists(cmd):
                    resp.set_header('Content-Encoding', 'gzip')
                    print("Compressing with %s" % cmd)
                    compressor = subprocess.Popen((cmd,), stdin=streamer.stdout, stdout=subprocess.PIPE)
                    resp.stream = compressor.stdout
                    break
            else:
                print("No gzip compressors found, falling back to no compression")
        else:
            print("Client did not ask for compression")



app = falcon.API()
app.add_route("/api/template/", TemplateResource())
app.add_route("/api/template/{name}/arch/{arch}/version/", VersionResource())
app.add_route("/api/template/{name}/arch/{arch}/version/{version}/stream/", StreamingResource())

if __name__ == '__main__':
    from wsgiref.simple_server import make_server, WSGIServer
    from socketserver import ThreadingMixIn

    class ThreadingWSGIServer(ThreadingMixIn, WSGIServer): 
        pass


    name, _, uid, gid, gecos, root, shell = pwd.getpwnam(options.user)
    sudoer = os.path.join("/etc/sudoers.d", options.user)

    print("Serving %d templates from pool %s" % (
        len([j for j in os.listdir(options.pool) if j.startswith("@template:")]),
        options.pool))

    if uid == 0:
        print("Warning: running as root, this is not reccommended")
    elif not os.path.exists(sudoer):
        print("Please create %s with following content: %s ALL=(ALL) NOPASSWD: /sbin/btrfs send /var/butterknife/pool/@template:*" % (sudoer, options.name))

    print("Listening on %s:%d" % (options.address, options.port))
    httpd = make_server(options.address, options.port, app, ThreadingWSGIServer)
    if uid:
        print("Switching to user %s (uid=%d, gid=%d)" % (name, uid, gid))
        os.setgid(gid)
        os.setuid(uid)
    httpd.serve_forever()

