#!/usr/bin/python3
import os
import click
from urllib.parse import urlparse
import json
import urllib.request

import subprocess

class Template(object):
    def __init__(self, address):
        self.o = urlparse(address)
        subvol = os.path.basename(self.o.path)
        _, fqn, self.architecture, self.version = subvol.split(":")
        self.namespace, self.identifier = fqn.rsplit(".", 1)

    def __repr__(self):
        return "@template:%s.%s:%s:%s" % (self.namespace, self.identifier, self.architecture, self.version)

    def __eq__(self, other):
        return self.o == other.o

    def __gt__(self, other):
        return self.o > other.o

    def __hash__(self):
        return hash(repr(self))

class Pool(object):
    def __init__(self, address):
        o = urlparse(address)
        assert o.scheme in ("http", "https", "ssh", "file"), "Invalid transport %s" % o.scheme
        if o.scheme == "file":
            assert not o.netloc, "Username, hostname or port not supported for file:// transport"

        assert not o.password
        assert not o.fragment
        assert not o.query

        self.scheme = o.scheme
        self.port = o.port
        self.username = o.username
        self.hostname = o.hostname

        if o.path:
            self.path = o.path
        else:
            self.path = "/var/butterknife/pool"
        if not self.path.endswith("/"):
            self.path += "/"

    def __str__(self):
        url = ""
        if self.scheme != "file":
            url += self.scheme + "://"
        if self.username:
            url += "%s@" % self.username
        if self.hostname:
            url += self.hostname
        if self.port:
            url += ":%d" % self.port
        if self.path != "/var/butterknife/pool/":
            url += self.path
        elif self.scheme != "file":
            url += "/"
        return url

    def command_receive(self):
        if self.scheme == "file":
            return "btrfs", "receive", self.path
        if self.scheme == "ssh":
            cmd = "ssh", (self.username + "@" if self.username else "") + self.hostname,
            if self.port:
                cmd = cmd + ("-p", self.port)
            cmd += "btrfs", "receive", path
            return cmd
        else:
            raise Exception("Unable to receive to transport %s" % self.scheme)

    def command_send(self, subvol):
        if self.scheme == "file":
            return "btrfs", "send", os.path.join(self.path, subvol)
        if self.scheme == "ssh":
            cmd = "ssh", (self.username + "@" if self.username else "") + self.hostname,
            if self.port:
                cmd = cmd + ("-p", self.port)
            cmd += "btrfs", "send", os.path.join(self.path, subvol)
            return cmd
        else:
            raise Exception("Unable to receive to transport %s" % self.scheme)

    def filter_subvols(self, category="@template", namespace="*", identifier="*", architecture="*", version="*"):
        for entry in self.list_templates():
            if namespace != "*" and entry.namespace != namespace:
                continue
            if identifier != "*" and entry.identifier != identifier:
                continue
            if architecture != "*" and entry.architecture != architecture:
                continue
            if version != "*" and entry.version != version:
                continue
            yield entry

    def list_templates(self):
        if self.scheme == "file":
            path = self.path or "/var/butterknife/pool/"
            print("Listing local templates in %s" % path)
            for entry in os.listdir(path):
                if entry.startswith("@template:"):
                    yield Template("file://%s/%s" % (path, entry))
        elif self.scheme == "ssh":

            cmd = "ssh", (self.username + "@" if self.username else "") + self.hostname,
            if self.port:
                cmd = cmd + ("-p", self.port)
            cmd += "ls", self.path,
            print("Executing:", " ".join(cmd))
            for entry in subprocess.check_output(cmd).decode("utf-8").split("\n"):
                if entry.startswith("@template:"):
                    url = "ssh://"
                    if self.username:
                        url += self.u.username + "@"
                    url += self.hostname
                    if self.port:
                        url += ":%d" % self.port
                    url += self.path + "/" + entry
                    yield Template(url)
        elif self.scheme in ("http", "https"):
            fh = urllib.request.urlopen("%s://%s/api/template/" % (self.scheme, self.hostname))
            for entry in json.loads(fh.read().decode("ascii"))["templates"]:
                yield "%(namespace)s.%(identifier)s" % entry
        else:
            raise

@click.command(help="Pull subvolumes")
@click.option("--source", required=True, help="Source pool")
@click.option("--destination", default="file://", help="Target pool")
@click.option("-c", "--category", default="@template", help="Subvolume type")
@click.option("-n", "--namespace", default="*", help="Template namespace")
@click.option("-i", "--identifier", default="*", help="Template identifier")
@click.option("-a", "--architecture", default="*", help="Architecture")
@click.option("-v", "--version", default="*", help="Version")
def pull(source, destination, category, namespace, identifier, arch, version):
    click.echo("Pushing %s:%s.%s:%s:%s from %s to %s" % (category, namespace,
        identifier, architecture, version, source, destination))
    pool = Pool(source)
    pool.list_templates()

@click.command(help="Push subvolumes")
@click.option("--source", default="file://", help="Source pool")
@click.option("--destination", required=True, help="Destination pool")
@click.option("-c", "--category", default="@template", help="Subvolume type")
@click.option("-n", "--namespace", default="*", help="Template namespace")
@click.option("-i", "--identifier", default="*", help="Template identifier")
@click.option("-a", "--architecture", default="*", help="Architecture")
@click.option("-v", "--version", default="*", help="Version")
def push(source, destination, category, namespace, identifier, architecture, version):
    click.echo("Pushing %s:%s.%s:%s:%s from %s to %s" % (category, namespace,
        identifier, architecture, version, source, destination))



    source = Pool(source)
    dest = Pool(destination)
    click.echo("KOHALIKUD: %s" % set(source.list_templates()))
    click.echo("KAUGED: %s" % set(dest.list_templates()))
#    click.echo("Puljong:%s" % set(source.list_templates()).intersection(set(dest.list_templates())))

@click.command(help="List local or remote subvolumes")
@click.option("--pool", default="file:///var/butterknife/pool", help="Remote or local pool")
@click.option("-c", "--category", default="@template", help="Subvolume type")
@click.option("-n", "--namespace", default="*", help="Template namespace")
@click.option("-i", "--identifier", default="*", help="Template identifier")
@click.option("-a", "--architecture", default="*", help="Architecture")
@click.option("-v", "--version", default="*", help="Version")
def list(pool, **kwargs):
    click.echo("Listing %(category)s:%(namespace)s.%(identifier)s:%(architecture)s:%(version)s" % kwargs)
    pool = Pool(pool)
    for template in sorted(pool.filter_subvols(**kwargs)):
        click.echo("%s%s" % (pool, template))

@click.command("serve", help="Run built-in HTTP API server")
@click.option("--pool", default="file:///var/butterknife/pool", help="Remote or local pool")
@click.option("-c", "--category", default="@template", help="Subvolume type")
@click.option("-n", "--namespace", default="*", help="Template namespace")
@click.option("-i", "--identifier", default="*", help="Template identifier")
@click.option("-a", "--architecture", default="*", help="Architecture")
@click.option("-v", "--version", default="*", help="Version")
@click.option("-u", "--user", default="root", help="Run as user")
@click.option("-p", "--port", default=80, help="Listen port")
@click.option("-l", "--listen", default="0.0.0.0", help="Listen address")
def http_serve(pool, category, namespace, identifier, architecture, version, user, port, listen):
    click.echo("Serving %s:%s.%s:%s:%s from %s at %s:%d" % (category, namespace,
        identifier, architecture, version, pool, listen, port))


@click.command("receive", help="Receive subvolume over multicast")
@click.option("--pool", default="file:///var/butterknife/pool", help="Remote or local pool")
def multicast_receive(pool):
    cmd = "udp-receiver", "--nokbd"
    udpcast = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    pool = Pool(pool)
    btrfs = subprocess.Popen(pool.command_receive(), stdin=udpcast.stdout)
    udpcast.wait()

@click.command("send", help="Send subvolume over multicast")
@click.option("--pool", default="file:///var/butterknife/pool", help="Remote or local pool")
@click.option("-c", "--category", default="@template", help="Subvolume type")
@click.option("-n", "--namespace", required=True, help="Namespace")
@click.option("-i", "--identifier", required=True, help="Identifier")
@click.option("-a", "--architecture", required=True, help="Architecture")
@click.option("-v", "--version", required=True, help="Version")
@click.option("-m", "--min-wait", default=5, help="Wait until t seconds since first receiver connection has passed")
def multicast_send(pool, category, namespace, identifier, architecture, version):
    pool = Pool(pool)
    btrfs = subprocess.Popen(pool.command_send("%s:%s.%s:%s:%s" % (category, namespace, identifier, architecture, version)), stdout=subprocess.PIPE)
    cmd = "udp-sender", "--nokbd", "--no-progress", "--min-receivers", "1", "--min-wait", "5"
    udpcast = subprocess.Popen(cmd, stdin=btrfs.stdout)
    btrfs.wait()

@click.group(help="Receive or serve over multicast")
def multicast():
    pass

@click.group(help="Serve HTTP API")
def http():
    pass

@click.group()
def cli():
    pass

multicast.add_command(multicast_receive)
multicast.add_command(multicast_send)
http.add_command(http_serve)
cli.add_command(pull)
cli.add_command(push)
cli.add_command(list)
cli.add_command(multicast)
cli.add_command(http)

if __name__ == "__main__":
    cli()
