#!/usr/bin/python3
import os
import click
from urllib.parse import urlparse
import json
import urllib.request

import subprocess

class Template(object):
    def __init__(self, address):
        self.o = urlparse(address)
        subvol = os.path.basename(self.o.path)
        _, fqn, self.architecture, self.version = subvol.split(":")
        self.namespace, self.identifier = fqn.rsplit(".", 1)
        assert self.version.startswith("snap")
        self.numeric_version = int(self.version[4:])

    def __repr__(self):
        return str(self)

    def __str__(self):
        return "@template:%s.%s:%s:%s" % (self.namespace, self.identifier, self.architecture, self.version)

    def __eq__(self, other):
        return repr(self) == repr(other)

    def __gt__(self, other):
        return self.numeric_version > other.numeric_version

    def __gt__(self, other):
        return self.numeric_version > other.numeric_version

    def __hash__(self):
        return hash(repr(self))

class Pool(object):
    def __init__(self, address):
        o = urlparse(address)
        assert o.scheme in ("http", "https", "ssh", "file"), "Invalid transport %s" % o.scheme
        if o.scheme == "file":
            assert not o.netloc, "Username, hostname or port not supported for file:// transport"

        assert not o.password
        assert not o.fragment
        assert not o.query

        self.scheme = o.scheme
        self.port = o.port
        self.username = o.username
        self.hostname = o.hostname

        if o.path:
            self.path = o.path
        else:
            self.path = "/var/butterknife/pool"
        if not self.path.endswith("/"):
            self.path += "/"

    def __str__(self):
        url = ""
        if self.scheme != "file":
            url += self.scheme + "://"
        if self.username:
            url += "%s@" % self.username
        if self.hostname:
            url += self.hostname
        if self.port:
            url += ":%d" % self.port
        if self.path != "/var/butterknife/pool/":
            url += self.path
        elif self.scheme != "file":
            url += "/"
        return url

    def command_receive(self, parent_subvol=None):
        cmd = "/home/lauri/Projektid/btrfs-progs/btrfs", "receive", self.path

        if self.scheme == "file":
            prefix = ()
        elif self.scheme == "ssh":
            prefix = "ssh", (self.username + "@" if self.username else "") + self.hostname,
            if self.port:
                prefix += "-p", self.port

        else:
            raise Exception("Unable to receive to transport %s" % self.scheme)

        if parent_subvol:
            cmd += "-p", os.path.join(self.path, str(parent_subvol))

        print("command_receiv:", " ".join(cmd))
        return prefix + cmd


    def command_send(self, subvol, parent_subvol=None):
        if self.scheme == "file":
            cmd = "btrfs", "send", os.path.join(self.path, str(subvol))
        elif self.scheme == "ssh":
            cmd = "ssh", (self.username + "@" if self.username else "") + self.hostname,
            if self.port:
                cmd = cmd + ("-p", self.port)
            cmd += "btrfs", "send", os.path.join(self.path, str(subvol))
        else:
            raise Exception("Unable to receive to transport %s" % self.scheme)

        if parent_subvol:
            cmd += "-p", os.path.join(self.path, str(parent_subvol))

        print("command_send:", " ".join(cmd))
        return cmd

    def filter_templates(self, **kwargs):
        for entry in self.filter_subvols(**kwargs):
            yield entry.namespace, entry.identifier, entry.architecture

    def filter_subvols(self, category="@template", namespace="*", identifier="*", architecture="*", version="*"):
        for entry in self.list_subvols():
            if namespace != "*" and entry.namespace != namespace:
                continue
            if identifier != "*" and entry.identifier != identifier:
                continue
            if architecture != "*" and entry.architecture != architecture:
                continue
            if version != "*" and entry.version != version:
                continue
            yield entry

    def list_subvols(self):
        if self.scheme == "file":
            path = self.path or "/var/butterknife/pool/"
            print("Listing local templates in %s" % path)
            for entry in os.listdir(path):
                if entry.startswith("@template:"):
                    yield Template("file://%s/%s" % (path, entry))
        elif self.scheme == "ssh":
            cmd = "ssh", (self.username + "@" if self.username else "") + self.hostname,
            if self.port:
                cmd = cmd + ("-p", self.port)
            cmd += "ls", self.path,
            print("Executing:", " ".join(cmd))
            for entry in subprocess.check_output(cmd).decode("utf-8").split("\n"):
                if entry.startswith("@template:"):
                    url = "ssh://"
                    if self.username:
                        url += self.u.username + "@"
                    url += self.hostname
                    if self.port:
                        url += ":%d" % self.port
                    url += self.path + "/" + entry
                    yield Template(url)
        elif self.scheme in ("http", "https"):
            fh = urllib.request.urlopen("%s://%s/api/template/" % (self.scheme, self.hostname))
            for entry in json.loads(fh.read().decode("ascii"))["templates"]:
                yield "%(namespace)s.%(identifier)s" % entry
        else:
            raise


@click.command(help="Pull templates")
@click.option("--source", required=True, help="Source pool")
@click.option("--destination", default="file://", help="Target pool")
@click.option("-n", "--namespace", default="*", help="Template namespace")
@click.option("-i", "--identifier", default="*", help="Template identifier")
@click.option("-a", "--architecture", default="*", help="Architecture")
@click.option("-v", "--version", default="*", help="Version")
def pull(source, destination, namespace, identifier, architecture, version):
    click.echo("Pushing @template:%s.%s:%s:%s from %s to %s" % (namespace,
        identifier, architecture, version, source, destination))

    source = Pool(source)
    dest = Pool(destination)

    for n, i, a in set(source.filter_templates(namespace=namespace, identifier=identifier, architecture=architecture)):
        remote_subvols = sorted(source.filter_subvols(namespace=n, identifier=i, architecture=a))
        local_subvols = sorted(dest.filter_subvols(namespace=n, identifier=i, architecture=a))

        click.echo("%d remote subvolumes of %s.%s:%s" % (len(remote_subvols), n,i,a))
        click.echo("%d local subvolumes of %s.%s:%s" % (len(local_subvols), n,i,a))
        
        common_subvols = set(remote_subvols).intersection(set(local_subvols))

        if common_subvols:
            parent_subvol = sorted(common_subvols)[-1]
            click.echo("Last common subvol is: %s" % parent_subvol)
            following_subvols = tuple(filter(lambda subvol: subvol > parent_subvol, remote_subvols))
        else:
            parent_subvol = None
            following_subvols = remote_subvols
            click.echo("No shared subvolumes!")

        if not following_subvols:
            click.echo("All versions of %s.%s:%s synchronized, skipping!" % (n,i,a))
            continue

        for subvol in following_subvols:
            if parent_subvol:
                click.echo("Fetching incremental snapshot %s relative to %s" % (subvol.version, parent_subvol.version))
            else:
                click.echo("Fetching full snapshot %s" % subvol.version)
            btrfs_send = subprocess.Popen(source.command_send(subvol, parent_subvol), stdout=subprocess.PIPE, close_fds=True)
            pv = subprocess.Popen(("pv",), stdin=btrfs_send.stdout, stdout=subprocess.PIPE, close_fds=True)
            btrfs_receive = subprocess.Popen(dest.command_receive(parent_subvol), stdin=pv.stdout, close_fds=True)
            btrfs_receive.communicate()
            parent_subvol = subvol
            click.echo("")

@click.command(help="Push subvolumes")
@click.option("--source", default="file://", help="Source pool")
@click.option("--destination", required=True, help="Destination pool")
@click.option("-c", "--category", default="@template", help="Subvolume type")
@click.option("-n", "--namespace", default="*", help="Template namespace")
@click.option("-i", "--identifier", default="*", help="Template identifier")
@click.option("-a", "--architecture", default="*", help="Architecture")
@click.option("-v", "--version", default="*", help="Version")
def push(source, destination, category, namespace, identifier, architecture, version):
    click.echo("Pushing %s:%s.%s:%s:%s from %s to %s" % (category, namespace,
        identifier, architecture, version, source, destination))

    source = Pool(source)
    dest = Pool(destination)
    raise NotImplementedError()

@click.command(help="List local or remote subvolumes")
@click.option("--pool", default="file:///var/butterknife/pool", help="Remote or local pool")
@click.option("-c", "--category", default="@template", help="Subvolume type")
@click.option("-n", "--namespace", default="*", help="Template namespace")
@click.option("-i", "--identifier", default="*", help="Template identifier")
@click.option("-a", "--architecture", default="*", help="Architecture")
@click.option("-v", "--version", default="*", help="Version")
def list(pool, **kwargs):
    click.echo("Listing %(category)s:%(namespace)s.%(identifier)s:%(architecture)s:%(version)s" % kwargs)
    pool = Pool(pool)
    for template in sorted(pool.filter_subvols(**kwargs)):
        click.echo("%s%s" % (pool, template))

@click.command("serve", help="Run built-in HTTP API server")
@click.option("--pool", default="file:///var/butterknife/pool", help="Remote or local pool")
@click.option("-c", "--category", default="@template", help="Subvolume type")
@click.option("-n", "--namespace", default="*", help="Template namespace")
@click.option("-i", "--identifier", default="*", help="Template identifier")
@click.option("-a", "--architecture", default="*", help="Architecture")
@click.option("-v", "--version", default="*", help="Version")
@click.option("-u", "--user", default="root", help="Run as user")
@click.option("-p", "--port", default=80, help="Listen port")
@click.option("-l", "--listen", default="0.0.0.0", help="Listen address")
def http_serve(pool, category, namespace, identifier, architecture, version, user, port, listen):
    click.echo("Serving %s:%s.%s:%s:%s from %s at %s:%d" % (category, namespace,
        identifier, architecture, version, pool, listen, port))


@click.command("receive", help="Receive subvolume over multicast")
@click.option("--pool", default="file:///var/butterknife/pool", help="Remote or local pool")
def multicast_receive(pool):
    cmd = "udp-receiver", "--nokbd"
    udpcast = subprocess.Popen(cmd, stdout=subprocess.PIPE)
    pool = Pool(pool)
    btrfs = subprocess.Popen(pool.command_receive(), stdin=udpcast.stdout)
    udpcast.wait()

@click.command("send", help="Send subvolume over multicast")
@click.option("--pool", default="file:///var/butterknife/pool", help="Remote or local pool")
@click.option("-c", "--category", default="@template", help="Subvolume type")
@click.option("-n", "--namespace", required=True, help="Namespace")
@click.option("-i", "--identifier", required=True, help="Identifier")
@click.option("-a", "--architecture", required=True, help="Architecture")
@click.option("-v", "--version", required=True, help="Version")
@click.option("-m", "--min-wait", default=5, help="Wait until t seconds since first receiver connection has passed")
def multicast_send(pool, category, namespace, identifier, architecture, version):
    pool = Pool(pool)
    btrfs = subprocess.Popen(pool.command_send("%s:%s.%s:%s:%s" % (category, namespace, identifier, architecture, version)), stdout=subprocess.PIPE)
    cmd = "udp-sender", "--nokbd", "--no-progress", "--min-receivers", "1", "--min-wait", "5"
    udpcast = subprocess.Popen(cmd, stdin=btrfs.stdout)
    btrfs.wait()

@click.group(help="Receive or serve over multicast")
def multicast():
    pass

@click.group(help="Serve HTTP API")
def http():
    pass

@click.group()
def cli():
    pass

multicast.add_command(multicast_receive)
multicast.add_command(multicast_send)
http.add_command(http_serve)
cli.add_command(pull)
cli.add_command(push)
cli.add_command(list)
cli.add_command(multicast)
cli.add_command(http)

if __name__ == "__main__":
    cli()
