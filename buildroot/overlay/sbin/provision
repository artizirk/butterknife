#!/bin/sh

# This script parses following arguments from /proc/cmdline:
#   - bk_url=https://mgmt.koodur.com/api
#   - bk_template=your-template
#   - bk_snapshot=snap9
#   - bk_domain=32kk.lan

# TODO: Make sure fdisk from busybox is NOT used, it's counting sectors incorrectly (?!)
# Dependencies: fdisk btrfs find dialog ntfs-3g ntfsprogs parted

# TODO: Check connectivity with API server
POOL_MOUNTPOINT=/mnt/pool
POOL_TEMPLATES=$POOL_MOUNTPOINT/templates
POOL_DEPLOYMENTS=$POOL_MOUNTPOINT/deployments
TARGET_MOUNTPOINT=/mnt/target

AGENT="Butterknife-Provisioning-Image/0.1"
URL_LOCAL=http://butterknife

# Clean up mess from interrupted snapshot retrieval
if [ -f $POOL_TEMPLATES/dirty ]; then
    echo "Interrupted snapshot cleanup not implemented yet!"
    #for subvol in $(cat $POOL_TEMPLATES/dirty); do
        # TODO: Handle these situations
    #done
fi

#######################################
### Check for presence of utilities ###
#######################################
for util in btrfs jq fdisk find ntfsresize udp-sender udp-receiver ntpdate curl; do
    if [ -z "$(which $util)" ]; then
        dialog --msgbox "Butterknife was unable to locate $util,\
            are you sure the provisioning image was compiled properly?" 0 0
        exit 253
    else
        echo "Found $util..."
    fi
done

set -x # Don't echo
set -e # Bail on error

#######################################
### Transfer method selection phase ###
#######################################

if [ -z $bk_template ] || [ -z $bk_snapshot ]; then
    TRANSFER_METHOD="http"
else
    TRANSFER_METHOD=$(dialog --menu "Select transfer method" 0 0 0 \
        http "HTTP-only" \
        multicast "Multicast receive" \
        tee "Multicast via HTTP and write" \
        proxy "Only proxy HTTP to multicast" 2>&1 >$(tty))
fi


##################################
### Harddisk preparation phase ###
##################################

case $TRANSFER_METHOD in
    http|multicast|tee)
        #############################
        ### Target disk selection ###
        #############################

        if [ -z "$(ls /sys/class/block/)" ]; then
            dialog --msgbox "Butterknife was unable to detect any harddisks,\
                are you sure harddisk is connected and we have drivers for it?" 0 0
            exit 255
        fi

        for disk in /sys/class/block/*; do
            if [ -d $disk/device ]; then
                slug=$(basename $disk)
                sector_count=$(cat $disk/size)
                sector_size=$(cat $disk/queue/hw_sector_size)
                # Hack around these dumbass cardreaders
                if [ "$sector_count" == "0" ]; then
                    continue
                fi
                size=$(expr $sector_count / 1000000 \* $sector_size / 1000)G
                echo "$slug \"$(cat $disk/device/model | xargs) ($size)\"";
            fi
        done > /tmp/disks

        dialog \
            --menu "Target disk" 0 0 0 \
            --file /tmp/disks \
            2> /tmp/selected_disk

        DISK_SLUG=$(cat /tmp/selected_disk)
        DISK=/dev/$DISK_SLUG

        PARTITIONING_METHOD=$(dialog --menu "Partitioning $DISK" 0 0 0 \
            purge           "Overwrite whole disk" \
            reformat        "Reformat partition" \
            unpartitioned   "Use unpartitioned area" \
            resize          "Resize last partition" \
            receive         "Receive into existing btrfs filesystem" \
            2>&1 >$(tty))

        # TODO: deploy          "Deploy received template" \
        # TODO: postinstall     "Run postinstall scripts (reinstall GRUB)" \

        # TODO: EFI way is not currently covered!
        case $PARTITIONING_METHOD in
            unpartitioned)
                clear 
                echo "Attempting to create new partition in unpartitioned space"
                echo -e "n\np\n\n\n\nw" | fdisk $DISK
            ;;
            resize)
                clear
                LAST_PARTITION=$(ls $DISK? | tail -n 1)
                SIZE="260G"
                ntfsresize -s $SIZE $LAST_PARTITION
                echo -e "d\n\nw" | fdisk $DISK # Remove last partition
                echo -e "n\np\n\n\n+$SIZE\nt\n\n7\nw" | fdisk $DISK # Re-create NTFS
#                ntfsresize -f $LAST_PARTITION
                echo -e "n\np\n\n\n\nw" | fdisk $DISK # Create partition for btrfs
            ;;
            purge)
                clear
                echo "Purging whole disk"
                echo -e "o\nn\np\n\n\n\nw" | fdisk $DISK
            ;;
        esac


        ############################################
        ### Target partition determination phase ###
        ############################################
        case $PARTITIONING_METHOD in
            reformat|receive)
                # Dialog to select partition for reformat or receive
                for partition in $DISK?; do
                    partition_slug=$(echo $partition | cut -d "/" -f 3)
                    sector_count=$(cat /sys/block/$DISK_SLUG/$partition_slug/size)
                    sector_size=$(cat /sys/block/$DISK_SLUG/queue/hw_sector_size)
                    size=$(expr $sector_count / 1000000 \* $sector_size / 1000)G
                    if [ $size == "0G" ]; then
                        size=$(expr $sector_count / 1000 \* $sector_size / 1000)M
                    fi
                    echo "$partition \"$size\"";
                done > /tmp/partitions

                PARTITION=$(dialog \
                    --menu "Target partition" 0 0 0 \
                    --file /tmp/partitions \
                    2>&1 >$(tty))
            ;;
            unpartitioned|resize|purge)
                # Assume last partition
                PARTITION=$(ls $DISK? | tail -n 1)
            ;;
            *)
                PARTITION=/dev/null
            ;;
        esac

        PARTITION_SLUG=$(echo $PARTITION | cut -d "/" -f 3)


        ########################################
        ### Target filesystem creation phase ###
        ########################################
        case $PARTITIONING_METHOD in
            purge|reformat|unpartitioned|resize) 
                clear
                echo "Creating clean btrfs filesystem on $PARTITON"
                mkfs.btrfs -f $PARTITION
            ;;
        esac

        # Attempt to mount target directory
        mkdir -p $POOL_MOUNTPOINT
        mount $PARTITION $POOL_MOUNTPOINT -o subvol=/
        mkdir -p $POOL_TEMPLATES
        mkdir -p $POOL_DEPLOYMENTS

        if [ $? -ne 0 ]; then
            dialog --msgbox "Mounting $PARTITION at $POOL_MOUNTPOINT failed, are you sure kernel has btrfs support built-in?" 0 0
            exit 255
        fi
    ;;
    *)
        PARTITIONING_METHOD="pass"
    ;;
esac

##############################
### Server selection phase ###
##############################
if [ -z $bk_url ]; then
    case $TRANSFER_METHOD in
        http|tee|proxy)
            bk_url=$(dialog --menu "Select server" 0 0 0 \
                $URL_LOCAL/api/                       "Use local or manually enter" \
                https://butterknife.koodur.com/api/   "Koodur LLC" 2>&1 >$(tty))
                
            if [ "$bk_url" == $URL_LOCAL ]; then
                bk_url=$(dialog --inputbox "Use local instance or customize URL" \
                    0 0 $URL_LOCAL 2>&1 >$(tty))
            fi
        ;;
    esac
fi

################################
### Template selection phase ###
################################
if [ -z $bk_template ]; then
    case $TRANSFER_METHOD in
        local)
            echo "" > /tmp/available_templates
            for i in $(ls $POOL_TEMPLATES); do
                echo "$i \"$i\"" >> /tmp/available_templates
            done
        ;;
        *)
            # Fetch template list
            curl -A $AGENT -s $bk_url/container/ \
                | jq '.containers[] | .name + " \"" + .description + "\""' -r \
                > /tmp/available_templates
        ;;
    esac

    bk_template=$(dialog \
        --menu "Select template to deploy" 0 0 0 \
        --file /tmp/available_templates \
        2>&1 >$(tty))
fi

################################
### Snapshot selection phase ###
################################
if [ -z $bk_snapshot ]; then
    case $TRANSFER_METHOD in
        http|tee|proxy|multicast)
            # Fetch snapshot list
            curl -A $AGENT -s $bk_url/container/$bk_template/snapshot/ \
                > /tmp/available_snapshots.json        

            cat /tmp/available_snapshots.json \
                | jq '.snapshots[] | .name+" \""+.comment + "\""' -r \
                | head -n 100 \
                > /tmp/available_snapshots
        ;;
        local)
            # List local snapshots
            echo "" > /tmp/available_snapshots
            for i in $(ls $POOL_TEMPLATES/$bk_template); do
                echo "$i \"$i\"" >> /tmp/available_snapshots
            done
        ;;
    esac


    case $TRANSFER_METHOD in
        http|tee|proxy|local|multicast)
            bk_snapshot=$(dialog \
                --menu "Select snapshot to deploy" 0 0 0 \
                --file /tmp/available_snapshots \
                2>&1 >$(tty))
        ;;
    esac
fi

bk_template_subvol=templates/$bk_template/$bk_snapshot/
clear

######################
### Hostname input ###
######################

FIRST_INTERFACE=$(ls /sys/class/net/ | grep -v '^lo$' | head -n 1)
MAC=$(cat /sys/class/net/$FIRST_INTERFACE/address | sed -e 's/://g')

case $PARTITIONING_METHOD in
    receive|pass)
        echo "Skipping setting hostname"
    ;;
    *)
        case $bk_hostname_policy in
            auto)
                bk_hostname="bk-$MAC" # Maximum of 15 characters due to MS legacy
            ;;
            *)
                bk_hostname=$(dialog --inputbox "Enter hostname" 0 0 "host-$MAC" 2>&1 >$(tty))
            ;;
        esac
    ;;
esac

#####################################
### Stream URL construction phase ###
#####################################

case $TRANSFER_METHOD in
    http|tee|proxy)
        # Build btrfs-stream URL
        STREAM="$bk_url/container/$bk_template/snapshot/$bk_snapshot/stream?src="
    ;;
esac


###############################################
### Allow differential snapshots using HTTP ###
###############################################

case $TRANSFER_METHOD in
    http)
        # Determine differential snapshot parents
        if [ -d $POOL_TEMPLATES/$bk_template ]; then
            cat /tmp/available_snapshots.json | jq -r '.snapshots[] .name' > /tmp/available_snapshot_names
            ls $POOL_TEMPLATES/$bk_template > /tmp/local_snapshot_names
            cat /tmp/local_snapshot_names /tmp/available_snapshot_names > /tmp/merged_snapshot_names

            PARENTS=$(cat /tmp/merged_snapshot_names | sort | grep -v $bk_snapshot | uniq -d)
            echo "Snapshot parents are: $PARENTS"
            for parent in $PARENTS; do
                STREAM="$STREAM$parent,"
            done
        else
            echo "Differential update not possible, because no snapshot parents available locally. Falling back to full snapshot"
        fi

        echo "Final URL is $STREAM"
    ;;
esac



# TODO: Mark dirty subvol

######################
### Transfer phase ###
######################

case $TRANSFER_METHOD in
    multicast)
        mkdir -p $POOL_MOUNTPOINT/$bk_template_subvol
        udp-receiver --nokbd \
            | zcat \
            | btrfs receive $POOL_MOUNTPOINT/$bk_template_subvol
    ;;
    http)
        mkdir -p $POOL_MOUNTPOINT/$bk_template_subvol
        curl -A $AGENT $STREAM \
            | zcat \
            | btrfs receive $POOL_MOUNTPOINT/$bk_template_subvol
    ;;
    tee)
        mkdir -p $POOL_MOUNTPOINT/$bk_template_subvol
        dialog --msgbox "Press enter once all the other machines are ready to receive" 0 0
        mkfifo /tmp/multicast_stream /tmp/local_stream
        zcat /tmp/local_stream | btrfs receive $POOL_MOUNTPOINT/$bk_template_subvol &
        sleep 1
        udp-sender --nokbd --no-progress --min-receivers 1 --min-wait 5 /tmp/multicast_stream &
        sleep 1
        curl -A $AGENT  -s $STREAM | tee /tmp/multicast_stream > /tmp/local_stream
        sleep 2
        # TODO: Ensure btrfs receive has finished
    ;;
    proxy)
        dialog --msgbox "Press enter once all the other machines are ready to receive" 0 0
        curl -A $AGENT -s $STREAM \
            | udp-sender --nokbd --min-receivers 1 --min-wait 5
    ;;
esac

sync

case $PARTITIONING_METHOD in
    pass)
        echo "Skipping template deployment"
    ;;
    *)
        #################################
        ### Template deployment phase ###
        #################################
        
        bk_deploy_subvol="deployments/$(date '+%Y-%m-%d_%H:%M:%S')"
        btrfs subvolume snapshot $POOL_MOUNTPOINT/$bk_template_subvol/* "$POOL_MOUNTPOINT/$bk_deploy_subvol"

        ###############################
        ### Run post-deploy scripts ###
        ###############################

        # Mount deployment subvolume at target directory
        mkdir -p $TARGET_MOUNTPOINT
        mount $PARTITION $TARGET_MOUNTPOINT -o subvol=$bk_deploy_subvol

        # Mount pool also for chroot
        mkdir -p $TARGET_MOUNTPOINT$POOL_MOUNTPOINT
        mount $PARTITION $TARGET_MOUNTPOINT$POOL_MOUNTPOINT -o subvol=/

        # Mount stuff for chroot
        mount --bind /dev/ $TARGET_MOUNTPOINT/dev/
        mount --bind /sys/ $TARGET_MOUNTPOINT/sys/
        mount --bind /proc/ $TARGET_MOUNTPOINT/proc/
        mount none $TARGET_MOUNTPOINT/tmp/ -t tmpfs

        # Export variables for postinstall scripts
        export BUTTERKNIFE_HOSTNAME=$bk_hostname
        export BUTTERKNIFE_DOMAIN=$bk_domain
        export BUTTERKNIFE_TEMPLATE_SUBVOL=$bk_template_subvol
        export BUTTERKNIFE_DEPLOY_SUBVOL=$bk_deploy_subvol
        export BUTTERKNIFE_PARTITION=$PARTITION
        export BUTTERKNIFE_DISK=$DISK
        export BUTTERKNIFE_POOL_MOUNTPOINT=$POOL_MOUNTPOINT
        export BUTTERKNIFE_PARTITIONING_METHOD=$PARTITIONING_METHOD # One of purge,reformat,unpartitionied,resize,receive
        export BUTTERKNIFE_TRANSFER_METHOD=$TRANSFER_METHOD # One of multicast,http,tee
        export BUTTERKNIFE_POOL_UUID=$(blkid -s UUID -o value $PARTITION)
        export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

        # Run postinstall scripts, presumably in sorted order
        chroot $TARGET_MOUNTPOINT butterknife-postdeploy
        
        case $PARTITIONING_METHOD in
            receive)
                echo "Skipping GRUB install"
            ;;
            *)
                case $bk_grub_method in
                    none)
                        echo "Skipping GRUB install"
                    ;;
                    volume)
                        chroot $TARGET_MOUNTPOINT grub-install $BUTTERKNIFE_DISK
                    ;;
                    both)
                        chroot $TARGET_MOUNTPOINT grub-install $BUTTERKNIFE_DISK
                        chroot $TARGET_MOUNTPOINT grub-install $BUTTERKNIFE_DISK
                    ;;
                    *)
                        chroot $TARGET_MOUNTPOINT grub-install $BUTTERKNIFE_DISK
                    ;;
                esac
            ;;
        esac

        # Unmount directories
        umount $TARGET_MOUNTPOINT/mnt/pool
        umount $TARGET_MOUNTPOINT/dev
        umount $TARGET_MOUNTPOINT/sys
        umount $TARGET_MOUNTPOINT/proc
        umount $TARGET_MOUNTPOINT/tmp
        umount $TARGET_MOUNTPOINT

        echo "Flushing buffers"
        sync
        sleep 1
        echo "Rebooting machine"
        reboot -f
    ;;
esac

